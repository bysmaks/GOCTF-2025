from dataclasses import dataclass
from Crypto.Util.number import *
from typing import List, Tuple
from gmpy2 import legendre
import os


@dataclass
class ПараметрыШифрования:
    модуль_n: int
    открытый_ключ_x: int
    зашифрованные_значения: List[int]


class ГроссВДжинсах:
    def __init__(self, размер_ключа: int = 2048):
        """
        Args:
            размер_ключа (int): Размер простых чисел в битах
        """
        self.размер_ключа = размер_ключа
        self.простое_p = None
        self.простое_q = None
        self.модуль_n = None
        self.открытый_ключ_x = None

    def сгенерировать_пару_ключей(self) -> Tuple[int, int]:
        """
        Returns:
            tuple: (модуль n, открытый ключ x)
        """
        self.простое_p, self.простое_q = getPrime(self.размер_ключа), getPrime(self.размер_ключа)
        self.модуль_n = self.простое_p * self.простое_q

        self.открытый_ключ_x = getRandomRange(0, self.модуль_n)
        while legendre(self.открытый_ключ_x, self.простое_p) != -1 or legendre(self.открытый_ключ_x, self.простое_q) != -1:
            self.открытый_ключ_x = getRandomRange(0, self.модуль_n)

        return self.модуль_n, self.открытый_ключ_x

    def зашифровать(self, сообщение: int) -> List[int]:
        """
        Args:
            сообщение (int): Сообщение для шифрования
        
        Returns:
            list: Список зашифрованных значений
        """
        if not self.модуль_n or not self.открытый_ключ_x:
            raise ValueError("Ключи не сгенерированы. Сначала вызовите сгенерировать_пару_ключей().")

        случайное_y = getRandomRange(0, self.модуль_n)
        зашифрованные_значения = []
        
        while сообщение:
            текущий_бит = сообщение & 1
            сообщение >>= 1
            зашифрованный_бит = (pow(случайное_y, 2) * pow(self.открытый_ключ_x, текущий_бит)) % self.модуль_n
            зашифрованные_значения.append(зашифрованный_бит)
            случайное_y += getRandomRange(1, 2**48)
        
        return зашифрованные_значения

    def получить_параметры_шифрования(self) -> ПараметрыШифрования:
        """
        Returns:
            ПараметрыШифрования: Текущие параметры шифрования
        """
        if not self.модуль_n or not self.открытый_ключ_x:
            raise ValueError("Ключи не сгенерированы. Сначала вызовите сгенерировать_пару_ключей().")
            
        return ПараметрыШифрования(
            модуль_n=self.модуль_n,
            открытый_ключ_x=self.открытый_ключ_x,
            зашифрованные_значения=[]
        )


class ЗаписьДанныхШифрования:
    def __init__(self, выходной_файл: str):
        """
        Args:
            выходной_файл (str): Путь к выходному файлу
        """
        self.выходной_файл = выходной_файл

    def сохранить_данные_шифрования(self, параметры: ПараметрыШифрования, зашифрованный_флаг: List[int]):
        """
        Args:
            параметры (ПараметрыШифрования): Параметры шифрования
            зашифрованный_флаг (list): Зашифрованные значения флага
        """
        os.makedirs(os.path.dirname(self.выходной_файл), exist_ok=True)
        
        with open(self.выходной_файл, 'w') as выходной_файл:
            выходной_файл.write(f"n = {параметры.модуль_n}\n")
            выходной_файл.write(f"x = {параметры.открытый_ключ_x}\n")
            выходной_файл.write(f"enc = {зашифрованный_флаг}\n")


def main() -> None:
    ФЛАГ = bytes_to_long(b'goctf{REDACTED}')
    ВЫХОДНОЙ_ФАЙЛ = './данные'

    шифровальщик = ГроссВДжинсах()
    
    шифровальщик.сгенерировать_пару_ключей()
    
    зашифрованный_флаг = шифровальщик.зашифровать(ФЛАГ)
    
    параметры = шифровальщик.получить_параметры_шифрования()
    
    писатель = ЗаписьДанныхШифрования(ВЫХОДНОЙ_ФАЙЛ)
    писатель.сохранить_данные_шифрования(параметры, зашифрованный_флаг)

    print(f"Данные шифрования сохранены в {ВЫХОДНОЙ_ФАЙЛ}")
    print(f"Флаг: {ФЛАГ}")
    print(f"Зашифрованный флаг: {зашифрованный_флаг}")
    print(f"Параметры шифрования: {параметры}")
    return


if __name__ == "__main__":
    main()
